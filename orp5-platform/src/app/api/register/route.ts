import { NextResponse } from 'next/server';
import { supabase } from '@/lib/supabase';

export async function POST(request: Request) {
    try {
        const newRegistration = await request.json();

        // Save to Supabase
        const { data, error } = await supabase
            .from('Registration')
            .insert({
                data: newRegistration,
                // id is generated by default gen_random_uuid(), submittedAt default now()
            })
            .select('id')
            .single();

        if (error) {
            console.error("Error saving registration:", error);
            throw error;
        }

        return NextResponse.json({ success: true, ticketId: data.id });
    } catch (error) {
        console.error("Error saving registration:", error);
        return NextResponse.json({ error: 'Failed to save registration' }, { status: 500 });
    }
}

export async function GET() {
    try {
        const { data, error } = await supabase
            .from('Registration')
            .select('*')
            .order('submittedAt', { ascending: false });

        if (error) throw error;

        // Map back to expected structure (array of objects with id inside?)
        // The previous implementation utilized 'registrations.json' which was an array of objects.
        // Each object had: { ...data, id, submittedAt }
        // Our table has: { id, data, submittedAt }
        // We should flatten it to match frontend expectations if possible, or update frontend.
        // Let's flatten it here to minimize frontend breakage.

        const flattened = data.map((row: any) => ({
            ...row.data,
            id: row.id,
            submittedAt: row.submittedAt
        }));

        return NextResponse.json(flattened);
    } catch (e) {
        console.error("Error fetching registrations:", e);
        return NextResponse.json([]);
    }
}

